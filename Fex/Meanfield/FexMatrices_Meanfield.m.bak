function convStruct = FexMatrices_Meanfield(optsPhys,IDC)
%convStruct  = Matrices_MeanField(Pts,Int,~,optsPhys,~,~)
%************************************************************************
%convStruct  = Polar_SpectralFourier_ConvolutionMatrices(Pts,Int,optsPhys)
%DESCRIPTION:
% computes matrix M_conv such that
%           M_conv * g_i = int f(y1-y1t,y2-y2t)*g(y1t,y2t) dy1t dy2t,
%INPUT:
%  f   = function for which convolution is to be computed
%  Pts = data for grid points in computational and physical space:
%        - 'y1_kv' - y1-variable for each point of 2D-grid 
%        - 'y2_kv' - y2-variable for each point of 2D-grid
%        - 'x1'    - grid in computational space only fo 1st variable
%        - 'x2'    - grid in computational space only for 2nd variable
%  Int = Integration weight vector
%OUTPUT:
% M_conv = convolution matrix, size (N1*N2,N1*N2) , see above
%************************************************************************
    %optsPhys = Parameters.optsPhys;
    %v2struct(Parameters);             
    %v2struct(FexNum);

    nSpecies=length(optsPhys.nParticlesS);

    paramNames = optsPhys.potParams2Names;
    nParams    = length(paramNames);
    f          = str2func(optsPhys.V2DV2);

    if(strcmp(IDC.polar,'polar'))
        Phi = @PhiPolar;
    else
        Phi = @PhiCart;
    end
    
    for iSpecies = 1:nSpecies
        for jSpecies=1:nSpecies

            optsPhysIJ=optsPhys;


            for iParam=1:nParams

                paramValues = optsPhys.([paramNames{iParam} 'S']);
                paramIJ = paramValues(iSpecies,jSpecies);

                optsPhysIJ.(paramNames{iParam}) = paramIJ;

            end           

            convStruct(iSpecies,jSpecies).Conv = IDC.ComputeConvolutionMatrix(Phi,optsPhys.FexNum);            

        end
    end


    function z = PhiPolar(r,~)
         z = f(r,optsPhysIJ);
    end

    function z = PhiCart(x,y)
         z = f(sqrt(x.^2 + y.^2),optsPhysIJ);
    end

end
