
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Seppecher_M1Fin</title><meta name="generator" content="MATLAB 7.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2013-03-31"><meta name="DC.source" content="Seppecher_M1Fin.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }

  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">function</span> data = Seppecher_M1Fin(optsPhys,optsNum)
<span class="comment">%*************************************************************************</span>
<span class="comment">%data = Seppecher(optsPhys,optsNum)</span>
<span class="comment">%</span>
<span class="comment">%            (Eq)  0 =</span>
<span class="comment">% with   (BC Wall) 0 = Cn*normal*grad(rho_s) + cos(theta)*(rho-1)*rho</span>
<span class="comment">%(BC outer Radius) 0 = normal*grad(rho_s);</span>
<span class="comment">%</span>
<span class="comment">%*************************************************************************</span>
    disp([<span class="string">'** '</span>,optsNum.DDFTCode,<span class="string">' **'</span>]);

    <span class="comment">%************************************************</span>
    <span class="comment">%***************  Initialization ****************</span>
    <span class="comment">%************************************************</span>
    close <span class="string">all</span>;

    Maps = struct(<span class="string">'PhysSpace'</span>,@Comp_to_Phys,<span class="string">'CompSpace'</span>,@Phys_to_Comp);

    [kBT,nParticles,g,theta]   = LoadPhysData_Sepp(optsPhys);
    optsNum.PhysArea.y2Min = 0;
    y2Max  = optsNum.PhysArea.y2Max;
    y1Min  = optsNum.PhysArea.y1Min;   y1Max  = optsNum.PhysArea.y1Max;
    L1     = optsNum.PhysArea.L1;
    [N1,N2,PhysArea,SubArea,x1Plot,x2Plot,plotTimes] = LoadNumDataM1(optsNum,Maps);
    g     = optsPhys.g;
    D_A   = optsPhys.D_A;
    D_B   = optsPhys.D_B;
    rho_m = optsPhys.rho_m;
    nu    = optsPhys.nu;
    Ca    = optsPhys.Ca;

    FF = false(2*N1*N2,1); F = false(N1*N2,1);
    TT = true(2*N1*N2,1);  T = true(N1*N2,1);
    OO = ones(2*N1*N2,1);  O = ones(N1*N2,1);
    ZZ = zeros(2*N1*N2,1); Z = zeros(N1*N2,1);


    <span class="comment">%************************************************</span>
    <span class="comment">%****************  Preprocess  ****************</span>
    <span class="comment">%************************************************</span>
    tic
    [Pts,Diff,Int,Ind,Interp] = M1SpectralSpectral(Maps,N1,N2,x1Plot,x2Plot);

    [Path,InterpPath,Int_of_path,Int_SubOnFull] = SubSpace(SubArea,<span class="keyword">...</span>
                @M1SpectralSpectral_Interpolation,Pts,Maps,<span class="string">'normal'</span>,<span class="string">'cart'</span>);


    <span class="comment">%Test Diff.div</span>
<span class="comment">%     gTest = [Pts.y1_kv.*sin(Pts.y2_kv).*cos(Pts.y2_kv);-Pts.y1_kv.*sin(Pts.y2_kv).*sin(Pts.y2_kv)];</span>
<span class="comment">%     subplot(2,2,1); doPlots_SC_Polar(Interp,Pts,gTest(1:N1*N2));</span>
<span class="comment">%     subplot(2,2,2); doPlots_SC_Polar(Interp,Pts,gTest(1+N1*N2:end));</span>
<span class="comment">%     subplot(2,2,3); doPlots_SC_Polar(Interp,Pts,Diff.div*gTest);</span>
<span class="comment">%</span>
<span class="comment">%     %Test grad</span>
<span class="comment">%     gTest2 = Pts.y1_kv.*sin(Pts.y2_kv).*cos(Pts.y2_kv);</span>
<span class="comment">%     figure</span>
<span class="comment">%     subplot(2,1,1); doPlots_SC_Polar(Interp,Pts,gTest2);</span>
<span class="comment">%     subplot(2,1,2); doPlots_SC_Polar(Interp,Pts,Diff.grad(N1*N2+1:end,:)*gTest2);</span>

    <span class="comment">%Test Lap</span>
    <span class="comment">%gh = tanh(Pts.y1_kv);</span>
    <span class="comment">%doPlots_SC(Interp,Pts,Diff.Lap*gh);</span>
    <span class="comment">%mark = (Pts.y2_kv == Pts.y2_kv(400));</span>

<span class="comment">%    figure;</span>
<span class="comment">%    subplot(2,2,1); plot(Pts.y1_kv(mark),Diff.Lap(mark,:)*g);</span>
<span class="comment">%    subplot(2,2,2); plot(Pts.y1_kv(mark),Diff.Dy2(mark,:)*g);</span>
<span class="comment">%    subplot(2,2,3); plot(Pts.y1_kv(mark),Diff.DDy2(mark,:)*g);</span>
<span class="comment">%    subplot(2,2,4); plot(Pts.y1_kv(mark),Diff.Dy1(mark,:)*g);</span>

    IBB       = [Ind.bound;Ind.bound];


    <span class="comment">%Set (known) Velocity Boundary conditions</span>
    uwall = [-1*O ; 0*O]; <span class="comment">% BoundaryLayerWithSuction(0,0,0.1);</span>
    normU  = uwall(1);

    uvBound        = zeros(size(Pts.y1_kv));
    PtsBound.y1_kv = Pts.y1_kv(Ind.bound);
    PtsBound.y2_kv = Pts.y2_kv(Ind.bound);

    <span class="comment">%BC at wall</span>
    <span class="comment">%uvBound([Ind.bottom;Ind.bottom]) = uwall([Ind.bottom;Ind.bottom]);</span>

    <span class="comment">%BC at left infinity (y1 -&gt; -infinity)</span>
    <span class="comment">%uvBound([Ind.left;Ind.left]) = uwall([Ind.left;Ind.left]);</span>

    <span class="comment">%BC at right infinity (y1 -&gt; infinity)</span>
    <span class="comment">%uvBound([Ind.right;Ind.right]) = uwall([Ind.right;Ind.right]);</span>


    <span class="comment">%Initialization of Plotting Sets</span>
    y1s = (min(Interp.pts1):0.5:max(Interp.pts1))';
    y2s = (PhysArea.y2Max:0.5:(PhysArea.y2Max+2))';
    PtsPlotSepp.y1_kv = kron(y1s,ones(size(y2s)));
    PtsPlotSepp.y2_kv = kron(ones(size(y1s)),y2s);
    PtsPlotSepp.N1 = length(y1s);   PtsPlotSepp.N2 = length(y2s);


    y1s = (min(Interp.pts1):0.5:max(Interp.pts1))';
    y2s = (PhysArea.y2Min:0.5:(PhysArea.y2Max))';
    [interpPts1x,~] = Phys_to_Comp(y1s,0);
    [~,interpPts2x] = Phys_to_Comp(0,y2s);

    PtsPlot.y1_kv = kron(y1s,ones(size(y2s)));
    PtsPlot.y2_kv = kron(ones(size(y1s)),y2s);
    PtsPlot.N1 = length(y1s);   PtsPlot.N2 = length(y2s);

    InterpPlotUV   = M1SpectralSpectral_Interpolation(interpPts1x,interpPts2x,Pts,Maps);

    uv = ZZ;



    t_preprocess = toc;
    <span class="comment">%****************************************************************</span>
    <span class="comment">%******** Solve for equilibrium density distribution ************</span>
    <span class="comment">%****************************************************************</span>
    mu      = zeros(N1*N2,1);

    rho    = - tanh(3/4*Pts.y1_kv);
<span class="comment">%    y = fsolve(@ResiduumMuVel,[0;theta;rho;ZZ]);</span>
    <span class="keyword">for</span> k = 1:3
        <span class="comment">%nParticles = (pi/2 - theta)*(PhysArea.y1Max)^2;</span>
        GetMuVel();
    <span class="keyword">end</span>


    t_dynSol = toc;
    <span class="comment">%************************************************</span>
    <span class="comment">%****************  Postprocess  ****************</span>
    <span class="comment">%************************************************</span>

    accFlux   = X_t(:,1);
    X_t       = X_t(:,2:end)';
    rho_t     = exp((X_t-Vext*ones(1,length(outTimes)))/kBT);

    flux_t    = zeros(2*N1*N2,length(plotTimes));
    <span class="keyword">for</span> i = 1:length(plotTimes)
        flux_t(:,i) = GetFlux(X_t(:,i),plotTimes(i));
    <span class="keyword">end</span>

    Subspace = v2struct(Path,InterpPath,Int_of_path,Int_SubOnFull,accFlux);
    data     = v2struct(Pts,Diff,Int,Ind,Interp,Conv,X_t,rho_t,Subspace,<span class="keyword">...</span>
                        mu,flux_t,<span class="keyword">...</span>
                        t_preprocess,t_eqSol,t_dynSol);

    <span class="keyword">if</span>(~isfield(optsNum,<span class="string">'savefileDDFT'</span>))
        SaveToFile(optsNum.DDFTCode,v2struct(data,optsPhys,optsNum),getResultsPath());
    <span class="keyword">end</span>

	display([<span class="string">'Preprocessor, Computation time (sec): '</span>, num2str(t_preprocess)]);
    display([<span class="string">'Equilibrium Sol., Computation time (sec): '</span>, num2str(t_eqSol)]);
    display([<span class="string">'Dynamics, Computation time (sec): '</span>, num2str(t_dynSol)]);

    PlotDDFT(v2struct(optsPhys,optsNum,data));

    <span class="comment">%***************************************************************</span>
    <span class="comment">%   Physical Auxiliary functions:</span>
    <span class="comment">%***************************************************************</span>
    <span class="keyword">function</span> GetMuVel()
        <span class="keyword">for</span> j = 1:10
            disp(j);
            mu_offset = 0;
            disp(num2str(max(abs(f_eq([mu_offset;rho])))));
            <span class="comment">%        options = optimset('Jacobian','on','MaxIter',1000);        y   = fsolve(@f_eq,[0;rho],options);</span>
            <span class="comment">%y = NewtonMethod([0;rho]);</span>
            <span class="comment">%mu_offset = y(1);</span>
            <span class="comment">%rho = y(2:end);</span>
            doPlots_SC(Interp,Pts,rho);

            theta = pi/2; <span class="comment">%TODO!!! (pi-Path(1).Int_Scalar*rho/PhysArea.y1Max)/2;</span>
            disp([<span class="string">'theta:'</span> , num2str(theta)]);
            disp([<span class="string">'Error of mu-Eq (1):'</span> , num2str(max(abs(f_eq([mu_offset;rho]))))]);
           <span class="comment">%disp(['Residuum (1): ',num2str(max(abs(ResiduumMuVel([y(1);theta;rho;uv]))))]);</span>

            D_A  = fsolve(@GetMassInflux,0);

            <span class="comment">%***************************</span>
            <span class="comment">%Compute Boundary Conditions</span>
            <span class="comment">%***************************</span>
            uvBound(IBB) = GetSeppecherSolutionCart(PtsBound,1,D_A,D_B,theta);

            <span class="comment">%***************************</span>
            <span class="comment">%***** Do Velocity Computation ******</span>
            <span class="comment">%***************************</span>
            [mu,uv,A,b] = GetVelocityAndChemPot(rho);

            <span class="comment">%Plot Intermediate Steps</span>
            u = GetSeppecherSolutionCart(PtsPlotSepp,1,D_A,D_B,theta);

            subplot(2,1,1);
            NormQuiverPlotInterp_NSpecies(InterpPlotUV,Pts,uv,[normU 0],[0 -1],1,{<span class="string">'b'</span>});
            NormQuiverPlot_NSpecies(PtsPlotSepp,u,true(size(PtsPlotSepp.y1_kv)),[normU 0],[0 -1],1,{<span class="string">'r'</span>}); hold <span class="string">on</span>;
            doPlots_IP_Contour(Interp,rho);  hold <span class="string">off</span>;
            subplot(2,1,2);
            doPlots_SC(Interp,Pts,mu);
            disp([<span class="string">'Error of mu-Eq (2):'</span> , num2str(max(abs(f_eq([y(1);rho]))))]);
            disp([<span class="string">'Error of A-Eq (2):'</span> , num2str(max(abs(A*[mu;uv]-b)))]);
            disp([<span class="string">'Residuum (2): '</span>,num2str(max(abs(ResiduumMuVel([y(1);theta;rho;uv]))))]);
        <span class="keyword">end</span>
        figure
        u = GetSeppecherSolutionCart(PtsPlotSepp,1,D_A,D_B,theta);
        NormQuiverPlotPolar(Pts,uv,true(size(Pts.y1_kv)),[normU 0],[0 -1],1,<span class="string">'b'</span>); hold <span class="string">on</span>;
        NormQuiverPlotPolar(PtsPlotSepp,u,true(size(PtsPlotSepp.y1_kv)),[normU 0],[0 -1],1,<span class="string">'r'</span>); hold <span class="string">on</span>;
        doPlots_IP_Polar_Contour(Interp,rho);    hold <span class="string">off</span>;
        figure;
        doPlots_SC_Polar(Interp,Pts,mu);
        <span class="comment">%subplot(2,2,3);</span>
        <span class="comment">%doPlots_SC_Polar(Interp,Pts,Amu*mu+Buv*uv);</span>
        <span class="comment">%subplot(2,2,4);</span>
        <span class="comment">%doPlots_SC_Polar(Interp,Pts,A_cont_uv*uv);</span>

        disp([<span class="string">'Error of mu-Eq:'</span> , num2str(max(abs(f_eq([0;rho]))))]);
        disp([<span class="string">'Error of A-Eq:'</span> , num2str(max(abs(A*[mu;uv]-b)))]);

    <span class="keyword">end</span>


    <span class="keyword">function</span> [y,J] = f_eq(x)
        <span class="comment">%solves for T*log*rho + Vext</span>
        mu_offset    = x(1);

        rho_s = x(2:end);

        [y,J] = GetExcessChemicalPotential(rho_s,mu_offset+mu);

        y   = [Int*rho_s - nParticles;y];
        J   = [0,Int;J];
    <span class="keyword">end</span>

    <span class="keyword">function</span> [mu,uv,A,b] = GetVelocityAndChemPot(rho)

        rho_f          = rho +rho_m;

        [A,b] = GetMatrixContinuityAndMomentum(rho);

        gradRho_T      = transposeVec(Diff.grad*rho_f);
        logGradRho_T   = transposeVec(Diff.grad*log(rho_f));

        <span class="comment">%For boundary condition for chemical potential</span>
        Cmu     = -gradRho_T * Diff.grad - diag(rho_f)*Diff.Lap;                <span class="comment">%Cmu     = - Diff.div*diag(repmat(rho_f,2,1))*Diff.grad;</span>
        Cuv     = -Ca*(2+nu)*Diff.Lap*logGradRho_T;<span class="comment">%(logGradRho_T*Diff.LapVec + transposeVec(Diff.gradLap*log(rho_f)));</span>
        C       = [Cmu,Cuv];

        <span class="comment">%Boundary conditions for chemical potential at boundaries</span>
        A([Ind.bound;FF],:)   = C(Ind.bound,:);

        A  = [A;[1,zeros(1,3*N1*N2-1)]];<span class="comment">% A = [A;[Int,zeros(1,2*N1*N2)]];</span>
        b = [b;0];
        x  = A\b;
        disp([<span class="string">'Error: '</span>,num2str(max(abs(A*x-b)))]);

        mu              = x(1:N1*N2);
        uv              = x(1+N1*N2:end);

        y = CheckMomentumEq(mu,uv);
        disp([<span class="string">'Error of divergence of stress tensor: '</span>,num2str(max(abs(y)))]);

    <span class="keyword">end</span>

    <span class="keyword">function</span> [y,J] = GetExcessChemicalPotential(rho_s,mu_offset)
        y            = - 9/8*(1-rho_s.^2).*rho_s - Diff.Lap*rho_s - mu_offset;
        J            = [-ones(N1*N2,1),9/8*diag(-1+3*rho_s.^2) - Diff.Lap];
    <span class="keyword">end</span>

    <span class="keyword">function</span> [A,b] = GetMatrixContinuityAndMomentum(rho)

        rho_f          = rho +rho_m;
        rho_f2         = repmat(rho_f,2,1);
        gradRho_T      = transposeVec(Diff.grad*rho_f);

        A_cont_mu      = zeros(N1*N2);
        A_cont_uv      = gradRho_T + diag(rho_f)*Diff.div;


        A_mom_mu       = -diag(rho_f2)*Diff.grad ;<span class="comment">%- [diag(Diff.Dy1*rho);diag(Diff.Dy2*rho)];</span>
        A_mom_uv       = Ca*(Diff.LapVec + (1+nu)*Diff.gradDivVec);

        A_cont         = [A_cont_mu,A_cont_uv];
        A_mom          = [A_mom_mu, A_mom_uv];
        Af             = [A_cont;A_mom];

        A                        = eye(3*N1*N2);
        A([~Ind.bound;~IBB],:)   = Af([~Ind.bound;~IBB],:);

        b          = zeros(N1*N2,1);<span class="comment">%- repmat( - 9/8*(1-rho.^2).*rho - Diff.Lap*rho,2,1).*(Diff.grad*rho); %</span>
        b([F;IBB]) = uvBound(IBB);
    <span class="keyword">end</span>

    <span class="keyword">function</span> [Amu,Auv,b] = GetStressTensorIJ(rho,i,j)

        <span class="comment">% get matrices for</span>
        <span class="comment">% T = Ca*( grad(u) + grad(u)^T + div(u)*I ) +...</span>
        <span class="comment">%   + (w(rho) + 0.5*|grad(u)|^2 - mu*rho)*I - grad(rho) X grad(rho)</span>

        bDiag   = 9/32*(1-rho.^2).^2 + 0.5*((Diff.Dy1*rho).^2 + (Diff.Dy2*rho).^2);
        <span class="keyword">if</span>(i == 1 &amp;&amp; j == 1)
            Amu     = -diag(rho+rho_m);
            Auv     = Ca*[2*Diff.Dy1 , zeros(N1*N2)] + Ca*nu*Diff.div;
            b       = bDiag - (Diff.Dy1*rho).*(Diff.Dy1*rho);
        <span class="keyword">elseif</span>((i==2 &amp;&amp; j == 1)  || (i==1 &amp;&amp; j == 2))
            Amu     = zeros(N1*N2);
            Auv     = Ca*[Diff.Dy2 , Diff.Dy1] ;
            b       = - (Diff.Dy1*rho).*(Diff.Dy2*rho);
        <span class="keyword">elseif</span>(i==2 &amp;&amp; j == 2)
            Amu     = -diag(rho+rho_m);
            Auv     = Ca*[zeros(N1*N2) , 2*Diff.Dy2] + Ca*nu*Diff.div;
            b       = bDiag - (Diff.Dy2*rho).*(Diff.Dy2*rho);
        <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="keyword">function</span> y = CheckMomentumEq(mu,uv)
        [A,b] = GetDivergenceOfStressTensor(rho);
        y = A*[mu;uv] + b;
    <span class="keyword">end</span>

    <span class="keyword">function</span> [A,b] = GetDivergenceOfStressTensor(rho)

        [Amu11,Auv11,b11] = GetStressTensorIJ(rho,1,1); A11 = [Amu11,Auv11];
        [Amu12,Auv12,b12] = GetStressTensorIJ(rho,1,2); A12 = [Amu12,Auv12];
        [Amu21,Auv21,b21] = GetStressTensorIJ(rho,2,1); A21 = [Amu21,Auv21];
        [Amu22,Auv22,b22] = GetStressTensorIJ(rho,2,2); A22 = [Amu22,Auv22];

        A1  = Diff.Dy1 * A11  + Diff.Dy2*A21;
        A2  = Diff.Dy1 * A12  + Diff.Dy2*A22;

        b1  = Diff.Dy1 * b11  + Diff.Dy2*b21;
        b2  = Diff.Dy1 * b12  + Diff.Dy2*b22;

        A   = [A1;A2];
        b   = [b1;b2];

    <span class="keyword">end</span>
    <span class="comment">%***************************************************************</span>
    <span class="comment">%Mapping functions:</span>
    <span class="comment">%***************************************************************</span>
    <span class="keyword">function</span> [y1_kv,y2_kv,J,dH1,dH2] = Comp_to_Phys(x1,x2)
        n  = length(x1);
        <span class="comment">%c2 = 0.3;</span>

        [y2_kv,dy2dx2] =  LinearMap(x2,0,PhysArea.y2Max);
        [h2,dh2,ddh2]  =  Interface(y2_kv);
        [y1_kv,Diffy1] =  M1TrefInterval(x1,PhysArea.y1Min,PhysArea.y1Max,h2,2);<span class="comment">% LinearMap(x1,PhysArea.y1Min,PhysArea.y1Max);% M1Tref(x1,0,0.07);</span>
        <span class="comment">%y1_kv          =  y1_kv + h2;</span>

        <span class="keyword">if</span>(nargout &gt;= 3)
            J        = zeros(n,2,2);
            J(:,1,1) = Diffy1.dydx;
            J(:,1,2) = dh2;
            J(:,2,1) = zeros(n,1);
            J(:,2,2) = dy2dx2;
        <span class="keyword">end</span>

        <span class="keyword">if</span>(nargout &gt;= 4)
            dH1        = zeros(n,2,2);
            dH1(:,1,1) = Diffy1.dyddx; <span class="comment">%d2y1dx1dx1;</span>
            dH1(:,1,2) = zeros(N1*N2,1);<span class="comment">%d2y1dx1dx2;</span>
            dH1(:,2,1) = zeros(N1*N2,1);<span class="comment">%d2y1dx1dx2;</span>
            dH1(:,2,2) = ddh2;
        <span class="keyword">end</span>

        <span class="keyword">if</span>(nargout &gt;= 4)
            dH2        = zeros(n,2,2);
            dH2(:,1,1) = zeros(n,1); <span class="comment">%d2y2dx1dx1;</span>
            dH2(:,1,2) = zeros(n,1); <span class="comment">%d2y2dx1dx2;</span>
            dH2(:,2,1) = zeros(n,1); <span class="comment">%d2y2dx1dx2;</span>
            dH2(:,2,2) = zeros(n,1); <span class="comment">%d2y2dx2dx2;</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">function</span> [x1,x2] = Phys_to_Comp(y1,y2)
        x2 = InvLinearMap(y2,0,y2Max);
        x1 = InvLinearMap(y1,y1Min,y1Max);
    <span class="keyword">end</span>

    <span class="keyword">function</span> [h2,dh2,ddh2] = Interface(y)
        h2    = y*0;
        dh2   = y*0;
        ddh2  = y*0;
    <span class="keyword">end</span>

    <span class="comment">%***************************************************************</span>
    <span class="comment">%Auxiliary functions:</span>
    <span class="comment">%***************************************************************</span>


    <span class="keyword">function</span> [kBT,nParticles,g,theta] = LoadPhysData_Sepp(optsPhys)
        kBT         = optsPhys.kBT;
        nParticles  = optsPhys.nParticles;
        g           = optsPhys.g;
        theta       = optsPhys.theta;
    <span class="keyword">end</span>
    <span class="keyword">function</span> rho = NewtonMethod(rho)
         options = struct(<span class="string">'TolFun'</span>,10^(-10),<span class="string">'MaxIter'</span>,2000);

         [v,J] = f_eq(rho);
         err = max(abs(v));
         i = 0;
         <span class="keyword">while</span>(err &gt; options.TolFun &amp;&amp; i &lt; options.MaxIter)
             rho    = rho -  J\v;
             [v,J]  = f_eq(rho);
             err    = norm(v);
             <span class="comment">%display(num2str(err));</span>
             i  = i+1;
         <span class="keyword">end</span>
         display([<span class="string">'Error: '</span>,num2str(err)]);
         display([<span class="string">'No of iterations: '</span> , num2str(i)]);
    <span class="keyword">end</span>

    <span class="keyword">function</span> aT = transposeVec(a)
        aT                = zeros(N1*N2,2*N1*N2);
        aT(:,1:N1*N2)     = diag(a(1:N1*N2));
        aT(:,1+N1*N2:end) = diag(a(1+N1*N2:end));
    <span class="keyword">end</span>

    <span class="keyword">function</span> m = GetMassInflux(dA)
        <span class="comment">%Density at infinity : -1,</span>
        <span class="comment">%Density at -infinity: 1.</span>
        <span class="comment">%dmCL   = ((-1+rho_m)-(1+rho_m))*(PhysArea.y2Max-0);</span>
        u_flow = GetSeppecherSolutionCart(Pts,1,dA,D_B,theta);
        m      = Int_of_path*(u_flow.*(repmat(rho,2,1)+rho_m));<span class="comment">% + dmCL;</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">Error using Seppecher_M1Fin (line 10)
Not enough input arguments.
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.14<br></p></div><!--
##### SOURCE BEGIN #####
function data = Seppecher_M1Fin(optsPhys,optsNum)
%************************************************************************* 
%data = Seppecher(optsPhys,optsNum)
%
%            (Eq)  0 = 
% with   (BC Wall) 0 = Cn*normal*grad(rho_s) + cos(theta)*(rho-1)*rho
%(BC outer Radius) 0 = normal*grad(rho_s);
%
%*************************************************************************   
    disp(['** ',optsNum.DDFTCode,' **']);
 
    %************************************************
    %***************  Initialization ****************
    %************************************************
    close all;
    
    Maps = struct('PhysSpace',@Comp_to_Phys,'CompSpace',@Phys_to_Comp);
        
    [kBT,nParticles,g,theta]   = LoadPhysData_Sepp(optsPhys);    
    optsNum.PhysArea.y2Min = 0;   
    y2Max  = optsNum.PhysArea.y2Max;
    y1Min  = optsNum.PhysArea.y1Min;   y1Max  = optsNum.PhysArea.y1Max;
    L1     = optsNum.PhysArea.L1;
    [N1,N2,PhysArea,SubArea,x1Plot,x2Plot,plotTimes] = LoadNumDataM1(optsNum,Maps);    
    g     = optsPhys.g;
    D_A   = optsPhys.D_A;
    D_B   = optsPhys.D_B;    
    rho_m = optsPhys.rho_m;
    nu    = optsPhys.nu;    
    Ca    = optsPhys.Ca;                 

    FF = false(2*N1*N2,1); F = false(N1*N2,1); 
    TT = true(2*N1*N2,1);  T = true(N1*N2,1); 
    OO = ones(2*N1*N2,1);  O = ones(N1*N2,1);
    ZZ = zeros(2*N1*N2,1); Z = zeros(N1*N2,1);

    
    %************************************************
    %****************  Preprocess  ****************
    %************************************************       
    tic    
    [Pts,Diff,Int,Ind,Interp] = M1SpectralSpectral(Maps,N1,N2,x1Plot,x2Plot);              
    
    [Path,InterpPath,Int_of_path,Int_SubOnFull] = SubSpace(SubArea,...
                @M1SpectralSpectral_Interpolation,Pts,Maps,'normal','cart');        
       
    
    %Test Diff.div
%     gTest = [Pts.y1_kv.*sin(Pts.y2_kv).*cos(Pts.y2_kv);-Pts.y1_kv.*sin(Pts.y2_kv).*sin(Pts.y2_kv)];
%     subplot(2,2,1); doPlots_SC_Polar(Interp,Pts,gTest(1:N1*N2));
%     subplot(2,2,2); doPlots_SC_Polar(Interp,Pts,gTest(1+N1*N2:end));
%     subplot(2,2,3); doPlots_SC_Polar(Interp,Pts,Diff.div*gTest);
%     
%     %Test grad
%     gTest2 = Pts.y1_kv.*sin(Pts.y2_kv).*cos(Pts.y2_kv);
%     figure
%     subplot(2,1,1); doPlots_SC_Polar(Interp,Pts,gTest2);
%     subplot(2,1,2); doPlots_SC_Polar(Interp,Pts,Diff.grad(N1*N2+1:end,:)*gTest2);        
    
    %Test Lap
    %gh = tanh(Pts.y1_kv);
    %doPlots_SC(Interp,Pts,Diff.Lap*gh);
    %mark = (Pts.y2_kv == Pts.y2_kv(400));
    
%    figure;
%    subplot(2,2,1); plot(Pts.y1_kv(mark),Diff.Lap(mark,:)*g);
%    subplot(2,2,2); plot(Pts.y1_kv(mark),Diff.Dy2(mark,:)*g);
%    subplot(2,2,3); plot(Pts.y1_kv(mark),Diff.DDy2(mark,:)*g);
%    subplot(2,2,4); plot(Pts.y1_kv(mark),Diff.Dy1(mark,:)*g);
            
    IBB       = [Ind.bound;Ind.bound];    
    
    
    %Set (known) Velocity Boundary conditions
    uwall = [-1*O ; 0*O]; % BoundaryLayerWithSuction(0,0,0.1);
    normU  = uwall(1);
   
    uvBound        = zeros(size(Pts.y1_kv));
    PtsBound.y1_kv = Pts.y1_kv(Ind.bound);
    PtsBound.y2_kv = Pts.y2_kv(Ind.bound);

    %BC at wall    
    %uvBound([Ind.bottom;Ind.bottom]) = uwall([Ind.bottom;Ind.bottom]);

    %BC at left infinity (y1 -> -infinity)
    %uvBound([Ind.left;Ind.left]) = uwall([Ind.left;Ind.left]);
    
    %BC at right infinity (y1 -> infinity)
    %uvBound([Ind.right;Ind.right]) = uwall([Ind.right;Ind.right]);
    
    
    %Initialization of Plotting Sets
    y1s = (min(Interp.pts1):0.5:max(Interp.pts1))';
    y2s = (PhysArea.y2Max:0.5:(PhysArea.y2Max+2))';    
    PtsPlotSepp.y1_kv = kron(y1s,ones(size(y2s)));
    PtsPlotSepp.y2_kv = kron(ones(size(y1s)),y2s);         
    PtsPlotSepp.N1 = length(y1s);   PtsPlotSepp.N2 = length(y2s);
    
    
    y1s = (min(Interp.pts1):0.5:max(Interp.pts1))';
    y2s = (PhysArea.y2Min:0.5:(PhysArea.y2Max))';    
    [interpPts1x,~] = Phys_to_Comp(y1s,0);
    [~,interpPts2x] = Phys_to_Comp(0,y2s);
    
    PtsPlot.y1_kv = kron(y1s,ones(size(y2s)));
    PtsPlot.y2_kv = kron(ones(size(y1s)),y2s);         
    PtsPlot.N1 = length(y1s);   PtsPlot.N2 = length(y2s);
    
    InterpPlotUV   = M1SpectralSpectral_Interpolation(interpPts1x,interpPts2x,Pts,Maps);        
        
    uv = ZZ;
    
    
    
    t_preprocess = toc;
    %****************************************************************
    %******** Solve for equilibrium density distribution ************
    %****************************************************************        
    mu      = zeros(N1*N2,1);    

    rho    = - tanh(3/4*Pts.y1_kv);    
%    y = fsolve(@ResiduumMuVel,[0;theta;rho;ZZ]);
    for k = 1:3
        %nParticles = (pi/2 - theta)*(PhysArea.y1Max)^2;        
        GetMuVel();
    end
    
    
    t_dynSol = toc;
    %************************************************
    %****************  Postprocess  ****************
    %************************************************        

    accFlux   = X_t(:,1);
    X_t       = X_t(:,2:end)';
    rho_t     = exp((X_t-Vext*ones(1,length(outTimes)))/kBT);
    
    flux_t    = zeros(2*N1*N2,length(plotTimes));
    for i = 1:length(plotTimes)
        flux_t(:,i) = GetFlux(X_t(:,i),plotTimes(i));
    end
    
    Subspace = v2struct(Path,InterpPath,Int_of_path,Int_SubOnFull,accFlux);
    data     = v2struct(Pts,Diff,Int,Ind,Interp,Conv,X_t,rho_t,Subspace,...
                        mu,flux_t,...
                        t_preprocess,t_eqSol,t_dynSol);                        
    
    if(~isfield(optsNum,'savefileDDFT'))
        SaveToFile(optsNum.DDFTCode,v2struct(data,optsPhys,optsNum),getResultsPath());
    end                    
                    
	display(['Preprocessor, Computation time (sec): ', num2str(t_preprocess)]);
    display(['Equilibrium Sol., Computation time (sec): ', num2str(t_eqSol)]);
    display(['Dynamics, Computation time (sec): ', num2str(t_dynSol)]);
    
    PlotDDFT(v2struct(optsPhys,optsNum,data));    
             
    %***************************************************************
    %   Physical Auxiliary functions:
    %***************************************************************             
    function GetMuVel()        
        for j = 1:10 
            disp(j);            
            mu_offset = 0;
            disp(num2str(max(abs(f_eq([mu_offset;rho])))));
            %        options = optimset('Jacobian','on','MaxIter',1000);        y   = fsolve(@f_eq,[0;rho],options);        
            %y = NewtonMethod([0;rho]);   
            %mu_offset = y(1);
            %rho = y(2:end);
            doPlots_SC(Interp,Pts,rho);    

            theta = pi/2; %TODO!!! (pi-Path(1).Int_Scalar*rho/PhysArea.y1Max)/2;
            disp(['theta:' , num2str(theta)]);
            disp(['Error of mu-Eq (1):' , num2str(max(abs(f_eq([mu_offset;rho]))))]);
           %disp(['Residuum (1): ',num2str(max(abs(ResiduumMuVel([y(1);theta;rho;uv]))))]);

            D_A  = fsolve(@GetMassInflux,0);

            %***************************
            %Compute Boundary Conditions
            %***************************
            uvBound(IBB) = GetSeppecherSolutionCart(PtsBound,1,D_A,D_B,theta);

            %***************************
            %***** Do Velocity Computation ******
            %***************************    
            [mu,uv,A,b] = GetVelocityAndChemPot(rho);

            %Plot Intermediate Steps    
            u = GetSeppecherSolutionCart(PtsPlotSepp,1,D_A,D_B,theta);

            subplot(2,1,1);
            NormQuiverPlotInterp_NSpecies(InterpPlotUV,Pts,uv,[normU 0],[0 -1],1,{'b'});
            NormQuiverPlot_NSpecies(PtsPlotSepp,u,true(size(PtsPlotSepp.y1_kv)),[normU 0],[0 -1],1,{'r'}); hold on;
            doPlots_IP_Contour(Interp,rho);  hold off;        
            subplot(2,1,2);
            doPlots_SC(Interp,Pts,mu); 
            disp(['Error of mu-Eq (2):' , num2str(max(abs(f_eq([y(1);rho]))))]);
            disp(['Error of A-Eq (2):' , num2str(max(abs(A*[mu;uv]-b)))]);            
            disp(['Residuum (2): ',num2str(max(abs(ResiduumMuVel([y(1);theta;rho;uv]))))]);
        end
        figure
        u = GetSeppecherSolutionCart(PtsPlotSepp,1,D_A,D_B,theta);
        NormQuiverPlotPolar(Pts,uv,true(size(Pts.y1_kv)),[normU 0],[0 -1],1,'b'); hold on;
        NormQuiverPlotPolar(PtsPlotSepp,u,true(size(PtsPlotSepp.y1_kv)),[normU 0],[0 -1],1,'r'); hold on;
        doPlots_IP_Polar_Contour(Interp,rho);    hold off;
        figure;
        doPlots_SC_Polar(Interp,Pts,mu);
        %subplot(2,2,3);
        %doPlots_SC_Polar(Interp,Pts,Amu*mu+Buv*uv);
        %subplot(2,2,4);    
        %doPlots_SC_Polar(Interp,Pts,A_cont_uv*uv); 

        disp(['Error of mu-Eq:' , num2str(max(abs(f_eq([0;rho]))))]);
        disp(['Error of A-Eq:' , num2str(max(abs(A*[mu;uv]-b)))]);

    end
    
    
    function [y,J] = f_eq(x)
        %solves for T*log*rho + Vext                        
        mu_offset    = x(1);
        
        rho_s = x(2:end);
        
        [y,J] = GetExcessChemicalPotential(rho_s,mu_offset+mu);
        
        y   = [Int*rho_s - nParticles;y];
        J   = [0,Int;J];
    end

    function [mu,uv,A,b] = GetVelocityAndChemPot(rho)
                        
        rho_f          = rho +rho_m;        
        
        [A,b] = GetMatrixContinuityAndMomentum(rho);
        
        gradRho_T      = transposeVec(Diff.grad*rho_f);
        logGradRho_T   = transposeVec(Diff.grad*log(rho_f));        
                
        %For boundary condition for chemical potential        
        Cmu     = -gradRho_T * Diff.grad - diag(rho_f)*Diff.Lap;                %Cmu     = - Diff.div*diag(repmat(rho_f,2,1))*Diff.grad;
        Cuv     = -Ca*(2+nu)*Diff.Lap*logGradRho_T;%(logGradRho_T*Diff.LapVec + transposeVec(Diff.gradLap*log(rho_f)));        
        C       = [Cmu,Cuv];        
        
        %Boundary conditions for chemical potential at boundaries
        A([Ind.bound;FF],:)   = C(Ind.bound,:);
        
        A  = [A;[1,zeros(1,3*N1*N2-1)]];% A = [A;[Int,zeros(1,2*N1*N2)]];
        b = [b;0];                
        x  = A\b;
        disp(['Error: ',num2str(max(abs(A*x-b)))]);

        mu              = x(1:N1*N2);
        uv              = x(1+N1*N2:end);
        
        y = CheckMomentumEq(mu,uv);
        disp(['Error of divergence of stress tensor: ',num2str(max(abs(y)))]);
        
    end

    function [y,J] = GetExcessChemicalPotential(rho_s,mu_offset)
        y            = - 9/8*(1-rho_s.^2).*rho_s - Diff.Lap*rho_s - mu_offset;  
        J            = [-ones(N1*N2,1),9/8*diag(-1+3*rho_s.^2) - Diff.Lap];
    end

    function [A,b] = GetMatrixContinuityAndMomentum(rho)
        
        rho_f          = rho +rho_m;
        rho_f2         = repmat(rho_f,2,1);
        gradRho_T      = transposeVec(Diff.grad*rho_f);        
        
        A_cont_mu      = zeros(N1*N2);        
        A_cont_uv      = gradRho_T + diag(rho_f)*Diff.div; 
        

        A_mom_mu       = -diag(rho_f2)*Diff.grad ;%- [diag(Diff.Dy1*rho);diag(Diff.Dy2*rho)];
        A_mom_uv       = Ca*(Diff.LapVec + (1+nu)*Diff.gradDivVec);

        A_cont         = [A_cont_mu,A_cont_uv];
        A_mom          = [A_mom_mu, A_mom_uv];
        Af             = [A_cont;A_mom];  
        
        A                        = eye(3*N1*N2);
        A([~Ind.bound;~IBB],:)   = Af([~Ind.bound;~IBB],:);
        
        b          = zeros(N1*N2,1);%- repmat( - 9/8*(1-rho.^2).*rho - Diff.Lap*rho,2,1).*(Diff.grad*rho); %
        b([F;IBB]) = uvBound(IBB);
    end

    function [Amu,Auv,b] = GetStressTensorIJ(rho,i,j)
        
        % get matrices for
        % T = Ca*( grad(u) + grad(u)^T + div(u)*I ) +...
        %   + (w(rho) + 0.5*|grad(u)|^2 - mu*rho)*I - grad(rho) X grad(rho)
                
        bDiag   = 9/32*(1-rho.^2).^2 + 0.5*((Diff.Dy1*rho).^2 + (Diff.Dy2*rho).^2);
        if(i == 1 && j == 1)
            Amu     = -diag(rho+rho_m);
            Auv     = Ca*[2*Diff.Dy1 , zeros(N1*N2)] + Ca*nu*Diff.div;     
            b       = bDiag - (Diff.Dy1*rho).*(Diff.Dy1*rho);
        elseif((i==2 && j == 1)  || (i==1 && j == 2))
            Amu     = zeros(N1*N2);
            Auv     = Ca*[Diff.Dy2 , Diff.Dy1] ;
            b       = - (Diff.Dy1*rho).*(Diff.Dy2*rho);            
        elseif(i==2 && j == 2)
            Amu     = -diag(rho+rho_m);
            Auv     = Ca*[zeros(N1*N2) , 2*Diff.Dy2] + Ca*nu*Diff.div;
            b       = bDiag - (Diff.Dy2*rho).*(Diff.Dy2*rho);                 
        end
        
    end

    function y = CheckMomentumEq(mu,uv)
        [A,b] = GetDivergenceOfStressTensor(rho);
        y = A*[mu;uv] + b;
    end

    function [A,b] = GetDivergenceOfStressTensor(rho)
        
        [Amu11,Auv11,b11] = GetStressTensorIJ(rho,1,1); A11 = [Amu11,Auv11];
        [Amu12,Auv12,b12] = GetStressTensorIJ(rho,1,2); A12 = [Amu12,Auv12];
        [Amu21,Auv21,b21] = GetStressTensorIJ(rho,2,1); A21 = [Amu21,Auv21];
        [Amu22,Auv22,b22] = GetStressTensorIJ(rho,2,2); A22 = [Amu22,Auv22];                
        
        A1  = Diff.Dy1 * A11  + Diff.Dy2*A21;
        A2  = Diff.Dy1 * A12  + Diff.Dy2*A22;
        
        b1  = Diff.Dy1 * b11  + Diff.Dy2*b21;
        b2  = Diff.Dy1 * b12  + Diff.Dy2*b22;
        
        A   = [A1;A2];
        b   = [b1;b2];      
        
    end
    %***************************************************************
    %Mapping functions:
    %***************************************************************
    function [y1_kv,y2_kv,J,dH1,dH2] = Comp_to_Phys(x1,x2)
        n  = length(x1);           
        %c2 = 0.3;        
        
        [y2_kv,dy2dx2] =  LinearMap(x2,0,PhysArea.y2Max);
        [h2,dh2,ddh2]  =  Interface(y2_kv);
        [y1_kv,Diffy1] =  M1TrefInterval(x1,PhysArea.y1Min,PhysArea.y1Max,h2,2);% LinearMap(x1,PhysArea.y1Min,PhysArea.y1Max);% M1Tref(x1,0,0.07); 
        %y1_kv          =  y1_kv + h2;
        
        if(nargout >= 3)
            J        = zeros(n,2,2);
            J(:,1,1) = Diffy1.dydx; 
            J(:,1,2) = dh2;
            J(:,2,1) = zeros(n,1);
            J(:,2,2) = dy2dx2;            
        end
        
        if(nargout >= 4)
            dH1        = zeros(n,2,2);
            dH1(:,1,1) = Diffy1.dyddx; %d2y1dx1dx1; 
            dH1(:,1,2) = zeros(N1*N2,1);%d2y1dx1dx2;             
            dH1(:,2,1) = zeros(N1*N2,1);%d2y1dx1dx2;     
            dH1(:,2,2) = ddh2;
        end
        
        if(nargout >= 4)
            dH2        = zeros(n,2,2);
            dH2(:,1,1) = zeros(n,1); %d2y2dx1dx1; 
            dH2(:,1,2) = zeros(n,1); %d2y2dx1dx2;             
            dH2(:,2,1) = zeros(n,1); %d2y2dx1dx2;     
            dH2(:,2,2) = zeros(n,1); %d2y2dx2dx2;             
        end
    end
    function [x1,x2] = Phys_to_Comp(y1,y2)
        x2 = InvLinearMap(y2,0,y2Max);
        x1 = InvLinearMap(y1,y1Min,y1Max);
    end

    function [h2,dh2,ddh2] = Interface(y)
        h2    = y*0;
        dh2   = y*0;
        ddh2  = y*0;
    end    

    %***************************************************************
    %Auxiliary functions:
    %***************************************************************        

    
    function [kBT,nParticles,g,theta] = LoadPhysData_Sepp(optsPhys)
        kBT         = optsPhys.kBT;
        nParticles  = optsPhys.nParticles;
        g           = optsPhys.g;
        theta       = optsPhys.theta;
    end
    function rho = NewtonMethod(rho)        
         options = struct('TolFun',10^(-10),'MaxIter',2000);
        
         [v,J] = f_eq(rho);
         err = max(abs(v));
         i = 0;
         while(err > options.TolFun && i < options.MaxIter)            
             rho    = rho -  J\v;
             [v,J]  = f_eq(rho);
             err    = norm(v);
             %display(num2str(err));             
             i  = i+1;
         end
         display(['Error: ',num2str(err)]);
         display(['No of iterations: ' , num2str(i)]);
    end

    function aT = transposeVec(a)              
        aT                = zeros(N1*N2,2*N1*N2);
        aT(:,1:N1*N2)     = diag(a(1:N1*N2));
        aT(:,1+N1*N2:end) = diag(a(1+N1*N2:end));
    end

    function m = GetMassInflux(dA)
        %Density at infinity : -1,
        %Density at -infinity: 1.
        %dmCL   = ((-1+rho_m)-(1+rho_m))*(PhysArea.y2Max-0);        
        u_flow = GetSeppecherSolutionCart(Pts,1,dA,D_B,theta);
        m      = Int_of_path*(u_flow.*(repmat(rho,2,1)+rho_m));% + dmCL;
    end
end
##### SOURCE END #####
--></body></html>