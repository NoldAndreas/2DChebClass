classdef InfSpace < SpectralSpectral

    properties                
        L1,L2
        y10 = 0;
        y20 = 0;
    end
    
    methods        
        function this = InfSpace(Geometry)
            this@SpectralSpectral(Geometry.N(1),Geometry.N(2));
                        
            this.L1    = Geometry.L1;
            this.L2    = Geometry.L2;
            if(isfield(Geometry,'y10'))
                this.y10 = Geometry.y10;
            end
            if(isfield(Geometry,'y20'))
                this.y20 = Geometry.y20;
            end
            
            InitializationPts(this);            
        end                         
    end
    
    methods (Access = public)
        function [y1,dy1,dx,ddx,dddx,ddddx] = PhysSpace1(this,x1)                        
            [y1,dy1,dx,ddx,dddx,ddddx] = SqrtMap(x1,this.L1,inf);
            y1 = y1 + this.y10;
        end
        function x1 = CompSpace1(this,y1)            
            x1  = InvSqrtMap(y1-this.y10,this.L1,inf);
        end
        function [y2,dy2,dx,ddx,dddx,ddddx] = PhysSpace2(this,x2)                        
            [y2,dy2,dx,ddx,dddx,ddddx] = SqrtMap(x2,this.L2,inf);
            y2 = y2 + this.y20;
        end
        function x2 = CompSpace2(this,y2)            
            x2  = InvSqrtMap(y2-this.y20,this.L2,inf);
        end
        
        function M_conv = ComputeConvolutionMatrix_Pointwise(this,f,shapeParams)
            disp('Computing Convolution matrices...'); 

            n1 = this.N1;   n2 = this.N2;
            M_conv = zeros(n1*n2,n1*n2);  
            
            if(isfield(shapeParams,'R'))
                subShape = Disc(shapeParams);
                rRange = (-1:0.05:1)';
            elseif(isfield(shapeParams,'RMin'))
                if(isfield(shapeParams,'RMax'))
                    subShape = Annulus(shapeParams);
                    rRange = (-1:0.05:1)';
                else
                    subShape = InfAnnulus(shapeParams);
                    rRange = (-1:0.05:0.9)';
                end
            else
                subShape = InfDisc(shapeParams);
                rRange = (-0.9:0.05:0.9)';
            end
            
            Int_i    = subShape.ComputeIntegrationVector();
            Interp   = subShape.ComputeInterpolationMatrix(rRange,(0:0.02:1)',true,false);
            
            %2b) Compute f-values        
            
            % take r,theta -> x,y -> matrix of values at each pair of points
            subShapeCartPts = Pol2CartPts(subShape.Pts);
            fP       = f(subShapeCartPts.y1_kv,subShapeCartPts.y2_kv);
            
            figure
            doPlots_SC_Polar(Interp,subShape.Pts,fP);
            title('Interpolation of Convolution function'); drawnow;
            %pause(1);

            %2) Loop over all points
            y1_kv=this.Pts.y1_kv;
            y2_kv=this.Pts.y2_kv;
            
            for i=1:(n1*n2)
                y1pt = y1_kv(i); 
                y2pt = y2_kv(i);

                %2a) Compute points in subgrid
                subConvShapePts = shiftDisc(subShape.Pts,y1pt,y2pt,'cart');
                %subConvShapePts = Pol2CartPts(subShape.Pts);
                
                %2c) Compute Interpolation Matrix onto Subspace
                IP          = SubShapePts(this,subConvShapePts);

                %2e) Combine
                M_conv(i,:) = (Int_i.*fP')*IP;    
            end
            M_conv(isnan(M_conv)) = 0;
            
        end
        
        
        function testAll(this)
            
            int = this.ComputeIntegrationVector;
            
            diff = this.ComputeDifferentiationMatrix;
            
            y1 = this.Pts.y1_kv;
            y2 = this.Pts.y2_kv;
            
            g = 1/pi * exp( - (y1.^2 + y2.^2) );
            
            intError = (int*g -1)
            
            DError = max(abs(diff.Dy1*g - (-g.*2.*y1)))
           
            interp1 = (-1:0.01:1).';
            interp2 = interp1;

            Interp = this.ComputeInterpolationMatrix(interp1,interp2,true);
            
            gInterp = Interp.InterPol*g;
            
            gPlot =  1/pi * exp( - (Interp.pts1.^2 + Interp.pts2.^2) );
            
            interpError = max( abs ( gInterp - gPlot) )
            
            
            sigma1 = 1;  sigma2  = 2;
            mu1    = 0;  mu2     = 5;
            
            r = sqrt( y1.^2 + y2.^2 );
            
            M_conv = ComputeConvolutionMatrix(this,@g1);
            
            conv = M_conv*g2(y1,y2);
            
            test = exp( - ( r - (mu1+mu2) ).^2 / ( 2 * (sigma1^2 + sigma2^2) ) );
            test = test * 1 / ( 2*pi * (sigma1^2 + sigma2^2) );
            
            convRelError = max(abs(conv-test)./abs(test))
            
            temp = reshape(conv - test,this.N1,this.N2);
            surf(this.Pts.x1,this.Pts.x2,abs(temp));
             
%             surf(this.Pts.x1,this.Pts.x2,reshape(conv,this.N1,this.N2),'FaceColor','r');
%             hold on
%             surf(this.Pts.x1,this.Pts.x2,reshape(test,this.N1,this.N2),'FaceColor','b');

            
            % aux functions
            function g = g1(x,y)
               sigma = sigma1;
               mu    = mu1;
               
               R = sqrt(x.^2 + y.^2);
               
               g = ( 2*pi *sigma^2 ).^(-1) * exp( - (R-mu).^2/2/sigma^2 );
            end

            function g = g2(x,y)
               sigma = sigma2;
               mu    = mu2;
               
               R = sqrt(x.^2 + y.^2);
               
               g = ( 2*pi *sigma^2 ).^(-1) * exp( - (R-mu).^2/2/sigma^2 );
            end
            
        end
        
        
    end
end