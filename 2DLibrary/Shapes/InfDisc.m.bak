classdef InfDisc < Polar_SpectralFourier

    properties        
        L
        Origin = [0;0];                        
    end
    
    methods        
        function this = InfDisc(Geometry)
            this@Polar_SpectralFourier(Geometry.N(1),Geometry.N(2));
            this.L = Geometry.L;
            
            InitializationPts(this);
        end                         
    end
    
    methods (Access = public)
        function [r,dr,dx,ddx,dddx,ddddx] = PhysSpace1(this,x)
            [r,dr,dx,ddx,dddx,ddddx] = SqrtMap(x,this.L,inf);             
        end
        function xf = CompSpace1(this,r)
            xf = InvSqrtMap(r,this.L,inf);
        end
        function [th,dth,dx,ddx,dddx,ddddx] = PhysSpace2(this,xT)    
            [th,dth,dx,ddx,dddx,ddddx] = LinearMap01(xT,0,2*pi);
        end
        function xf = CompSpace2(this,th)
            xf = th/(2*pi);
        end
        
        function M_conv = ComputeConvolutionMatrix(this,f,shapeParams)
            disp('Computing Convolution matrices...'); 

            n1 = this.N1;   n2 = this.N2;
            M_conv = zeros(n1*n2,n1*n2);  
            
            if(isfield(shapeParams,'R'))
                subShape = Disc(shapeParams);
                rRange = (-1:0.05:1)';
            elseif(isfield(shapeParams,'RMin'))
                if(isfield(shapeParams,'RMax'))
                    subShape = Annulus(shapeParams);
                    rRange = (-1:0.05:1)';
                else
                    subShape = InfAnnulus(shapeParams);
                    rRange = (-1:0.05:0.9)';
                end
            else
                subShape = InfDisc(shapeParams);
                rRange = (-0.9:0.05:0.9)';
            end
            
            Int_i    = subShape.ComputeIntegrationVector();
            Interp   = subShape.ComputeInterpolationMatrix(rRange,(0:0.02:1)',true,false);
            
            %2b) Compute f-values        
            
            % take r,theta -> matrix of values at each pair of points 
            fP       = f(subShape.Pts.y1_kv,subShape.Pts.y2_kv);
            
            figure
            doPlots_SC_Polar(Interp,subShape.Pts,fP);
            title('Interpolation of Convolution function'); drawnow;
            %pause(1);

            %2) Loop over all points
            y1_kv=this.Pts.y1_kv;
            y2_kv=this.Pts.y2_kv;
            
            for i=1:(n1*n2)
                y10 = y1_kv(i); 
                y20 = y2_kv(i);

                %2a) Compute points in subgrid
                subConvShapePts = shiftDisc(subShape.Pts,y10,y20,'polar');
                %subConvShapePts = Pol2CartPts(subShape.Pts);
                
                %2c) Compute Interpolation Matrix onto Subspace
                IP          = SubShapePts(this,subConvShapePts);

                %2d) Compute integration weight vector
                %Int_i       = subConvShape.ComputeIntegrationVector();
                
                %2e) Combine
                M_conv(i,:) = (Int_i.*fP')*IP;    
            end
            M_conv(isnan(M_conv)) = 0;
            
        end
        
        function conv = ComputeConvolutionMatrix_Pointwise_Test(this,shapeParams)
            
            sigma1 = 1;  sigma2  = 2;
            mu1    = 0;  mu2     = 0;
            
            r = this.Pts.y1_kv;
            t = this.Pts.y2_kv;
            
%             % infinite disc, convolution of two Gaussians
%             shapeParams.N=[10;10]; shapeParams.L=2; 
%             M_conv = ComputeConvolutionMatrix_Pointwise(this,@g1,shapeParams);
%             
%             conv = M_conv*g2(r);
%             
%             test = exp( - ( r - (mu1+mu2) ).^2 / ( 2 * (sigma1^2 + sigma2^2) ) );
%             test = test * 1 / ( 2*pi * (sigma1^2 + sigma2^2) );
%             
%             plot(r, test)
%             hold on
%             plot(r,conv,'or')
%             
%             % convolution of a Gaussian with a constant on a disk (i.e.
%             % just integration of a Gaussian on a disk).
%             clear('shapeParams');
%             shapeParams.N=[10;10]; shapeParams.R=0.1; 
%             M_conv = ComputeConvolutionMatrix_Pointwise(this,@g4,shapeParams);
%  
%             conv = M_conv*g3(r,t);
%             
%             test = 1-exp(-shapeParams.R^2);
%             
%             max(abs(conv-test))
%             
%             % convolution of a Gaussian with a constant on a finite annulus
%             % (i.e. just integration of a Gaussian on an annulus).
%             clear('shapeParams');
%             shapeParams.N=[10;10]; shapeParams.RMin=1; shapeParams.RMax=4;
%             M_conv = ComputeConvolutionMatrix_Pointwise(this,@g4,shapeParams);
%  
%             conv = M_conv*g3(r,t);
%             
%             test = exp(-shapeParams.RMin^2)-exp(-shapeParams.RMax^2);
%             
%             max(abs(conv-test))
% 
%             % convolution of a Gaussian with a constant on an infinite annulus
%             % (i.e. just integration of a Gaussian on an annulus).
%             clear('shapeParams');
%             shapeParams.N=[20;10]; shapeParams.RMin=1; shapeParams.L = 1;
%             M_conv = ComputeConvolutionMatrix_Pointwise(this,@g4,shapeParams);
%  
%             conv = M_conv*g3(r,t);
%             
%             test = exp(-shapeParams.RMin^2);
%             
%             max(abs(conv-test))

%             % convolution of a Gaussian*sin(theta) with a constant on an 
%             % infinite annulus
%             clear('shapeParams');
%             shapeParams.N=[20;10]; shapeParams.RMin=1; shapeParams.L = 1;
%             M_conv = ComputeConvolutionMatrix_Pointwise(this,@g5,shapeParams);
%  
%             conv = M_conv*g3(r,t);
%             
%             test = 0;
%             
%             max(abs(conv-test))

            % convolution of a RP with a Gaussian on an infinite annulus
            clear('shapeParams');
            shapeParams.N=[22;16]; shapeParams.RMin=1; shapeParams.L = 1;
            M_conv = ComputeConvolutionMatrix(this,@w12_11,shapeParams);
            
            conv = M_conv*g4(r,t);
            
            test = 0;
            
            max(abs(conv-test))


            % aux functions
            function g = g1(r,t)
               sigma = sigma1;
               mu    = mu1;
               g = ( 2*pi *sigma^2 ).^(-1) * exp( - (r-mu).^2/2/sigma^2 );
            end

            function g = g2(r,t)
               sigma = sigma2;
               mu    = mu2;
               g = ( 2*pi *sigma^2 ).^(-1) * exp( - (r-mu).^2/2/sigma^2 );
            end
            
            function g = g3(r,t)
                g = ones(size(r));
            end
            
            function g = g4(r,t)
                g = 1/pi * exp(-r.^2);
            end
            
            function g = g5(r,t)
                g = 1/pi * exp(-r.^2) .* sin(t);
            end
            
            function g = ror11(r,t)
                g = cos(t).^2;
            end
            
            function g = ror22(r,t)
                g = sin(t).^2;
            end
            
            function g = ror12(r,t)
                g = cos(t).*sin(t);
            end
            
            function g = ror21(r,t)
                g = ror12(r,t);
            end
            
            function g = w12_11(r,t)
                g =   3/8 * r.^(-1) .* (1 +   ror11(r,t)) ...
                    + 1/6 * r.^(-3) .* (1 - 3*ror11(r,t));
                
            end
            
        end
       
        
    end
end