classdef (Abstract) Shape < handle
    
    properties (Access = public)                
        Pts
        Diff
        Int
        Ind
        Interp
        Conv
        
        BoundaryPaths %vector with [Path_right; PathUpper ; PathLeft ; PathBottom]
        
        N1 
        N2 
        polar = 'undefined';
    end
    
    methods (Abstract = true,Access = public)         
         [y1_kv,y2_kv,J,dH1,dH2] = PhysSpace(x1,x2);         
         [x1,x2]                 = CompSpace(y1,y2);
         
         Ind    = ComputeIndices(this);
         Diff   = ComputeDifferentiationMatrix(this);
         Interp = ComputeInterpolationMatrix(this,interp1,interp2,fullInterpGrid,saveBool);           
         Int    = ComputeIntegrationVector(this);
         M_conv = ComputeConvolutionMatrix(this,f,saveBool);
    end
    
    
	methods 
        function this = Shape(N1,N2)
            this.N1 = N1;
            this.N2 = N2;             
        end
    end
    
    methods (Access = public)
        
        function ptsCart = GetCartPts(this,pts_y1,pts_y2)
            
            if(nargin == 1)
                pts_y1 = this.Pts.y1_kv;
                pts_y2 = this.Pts.y2_kv;
            end
            
            if(strcmp(this.polar,'polar'))
                [ptsCart.y1_kv,ptsCart.y2_kv] = pol2cart(pts_y2,pts_y1);
            elseif(strcmp(this.polar,'sphSurf'))
                 th  = pts_y1;  phi = pts_y2;                          
                 ptsCart.y1_kv = this.R*sin(th).*cos(phi);
                 ptsCart.y2_kv = this.R*cos(th);            
            elseif(strcmp(this.polar,'cart'))                
                ptsCart.y1_kv = pts_y1;  ptsCart.y2_kv = pts_y2;
            else
                exc = MException('Shape:GetCartPts','select {polar,sphSurf,cart}');
                throw(exc);                
            end
            
        end       
        function [Pts,Diff,Int,Ind,Interp,Conv] = ComputeAll(this,PlotArea,f,shapeParam)
            Ind  = ComputeIndices(this);
            Diff = ComputeDifferentiationMatrix(this);
            Int  = ComputeIntegrationVector(this);
                        
            Pts    = this.Pts;            
            
            if(nargin >= 2)
                Interp = InterpolationPlot(this,PlotArea,true);  
            end                        
            if(nargin >= 3)
                if(nargin ==4)
                    Conv = ComputeConvolutionMatrix(this,f,shapeParam);
                else
                    Conv = ComputeConvolutionMatrix(this,f,true);
                end
            end
        end        
        function this = InitializationPts(this)
            this.Pts.x1_kv  = kron(this.Pts.x1,ones(this.N2,1));
            this.Pts.x2_kv  = kron(ones(this.N1,1),this.Pts.x2);
            
            [this.Pts.y1_kv,this.Pts.y2_kv] = PhysSpace(this,this.Pts.x1_kv,...
                                                        this.Pts.x2_kv);
            this.Pts.N1 = this.N1;
            this.Pts.N2 = this.N2;
        end    
        function IP = InterpolationMatrix_Pointwise(this,y1P,y2P)            
            IP = zeros(length(y1P),this.N1*this.N2);            
            for i =1:length(y1P)
                [x1,x2] = CompSpace(this,y1P(i),y2P(i));
                h       = ComputeInterpolationMatrix(this,x1,x2);
                IP(i,:) = h.InterPol;
            end                                
        end       
        function IP = SubShapePts(this,a_shapePts)                   
            IP = InterpolationMatrix_Pointwise(this,a_shapePts.y1_kv,...
                                                    a_shapePts.y2_kv);                           
        end                
        function IP = InterpolationPlot(this,PlotArea,saveBool)
            
            [x1min,x2min] = CompSpace(this,PlotArea.y1Min,PlotArea.y2Min);
            [x1max,x2max] = CompSpace(this,PlotArea.y1Max,PlotArea.y2Max);
            
            y1Plot = GetArray(x1min,x1max,PlotArea.N1);
            y2Plot = GetArray(x2min,x2max,PlotArea.N2);
            
            if(nargin == 3)            
                IP = ComputeInterpolationMatrix(this,y1Plot,y2Plot,true,saveBool);           
            else
                IP = ComputeInterpolationMatrix(this,y1Plot,y2Plot,true,false);           
            end
        end                    
        function [AD,AAD] = GetAverageDensities(this,r,N,discCircle,weights)
            %AD  - Average densities to get average densities
            %AAD - average the average densities to compute free energy
            
            %A - Loop through all points in Box
            %The first N2 iterations loop through y2. Here, we save the Pts
            %and the integration weights
                        
            M          = this.N1*this.N2;
            shape.N    = N;
            shape.R    = r;
            
            if(strcmp(discCircle,'disc'))
                area                   = Disc(shape);
                dataS.ptsPolLoc        = area.Pts;
             elseif(strcmp(discCircle,'circle'))
                area                   = Circle(shape);               
                dataS.ptsPolLoc        = area.Pts;
             elseif(strcmp(discCircle,'sphere'))
                shape.sphere           = true;
                area                   = Disc(shape);                
                dataS.ptsPolLoc        = area.Pts;                        
             elseif(strcmp(discCircle,'ball'))
                shape.theta1    = 0;
                shape.theta2    = pi;                             
                area            = Ball(shape);                                             
                dataS.ptsPolLoc = Cart2PolPts(area.PtsCart);                                                    
            else
                exc = MException('Shape:GetAverageDensities','case not implemented');
                throw(exc);
            end
            
            dataS.pts               = area.GetCartPts();
            [dataS.int,dataS.area]  = area.ComputeIntegrationVector();                  
            
            [AD,checkAD]  = InterpolateAndIntegratePtsOrigin(this,this.Pts,dataS,weights);                       
            AAD           = AD;
            %**********************************************************            
            %**********************************************************
            
            %Test:
            [errAD,ierrAD] = max(abs(checkAD - sum(AD(:,:,1),2)));            
            y1err          = this.Pts.y1_kv(ierrAD);
            y2err          = this.Pts.y2_kv(ierrAD);
            disp(['Max. Error in AD: ', num2str(errAD),...
                          ' at y_1= ', num2str(y1err),...
                          ' at y_2= ', num2str(y2err)]);
                      
            %**********************************************************                       
             
        end                          
        function [X,checkSum] = InterpolateAndIntegratePtsOrigin(this,ptsOr,data,weights)
            
            m        = length(ptsOr.y1_kv );
            mThis    = length(this.Pts.y1_kv);
            noW      = size(weights,1);
            
            X        = zeros(m,mThis,noW+1);%always include unity weight
            checkSum = zeros(m,1);
            %Go through all points in box
            for iPts = 1:m
                
                pts        = data.pts;                
                
                pts.y1_kv  = pts.y1_kv + ptsOr.y1_kv(iPts);
                pts.y2_kv  = pts.y2_kv + ptsOr.y2_kv(iPts);                                                                        

                %Interpolate onto the new set of points
                IP    = SubShapePts(this,pts);

                %Finally get correct integration weight
                X(iPts,:,1)       = data.int*IP;
                for k = 1:noW
                    f = str2func(weights(k,:));
                    X(iPts,:,1+k) = (data.int.*f(data.ptsPolLoc.y2_kv)')*IP;                
                end
                checkSum(iPts)  = data.area;                                
            end
        end
        

        function doPlotsFlux(this,flux,maskAdd,fl_norm,lw,c)
            
            nSpecies=size(flux,2);
            if(nSpecies == 1)
                nCol = 1;
            else
                nCol = 2;
            end
            %ma3 = (~Ind.bound  & (Pts.y1_kv >=  min(y1Plot)) & (Pts.y1_kv <=  max(y1Plot)) & (Pts.y2_kv <=  max(y2Plot)) & (Pts.y2_kv >=  min(y2Plot)));
            mask    = ((this.Pts.y1_kv <= max(this.Interp.pts1)) & ...
                               (this.Pts.y1_kv >= min(this.Interp.pts1)) & ...
                               (this.Pts.y2_kv <= max(this.Interp.pts2)) & ...
                               (this.Pts.y2_kv >= min(this.Interp.pts2)));                                                           
            if(exist('maskAdd','var') && ~isempty(maskAdd))                           
                mask   = (maskAdd & mask);                
            end
            if(sum(mask)==0)
                return;
            end           
            
            nRows  = ceil(nSpecies/nCol);                
            %yCart  = GetCartPts(this,this.Interp.pts1,this.Interp.pts2);
            yCart  = GetCartPts(this,this.Pts.y1_kv,this.Pts.y2_kv);
            y1_s   = yCart.y1_kv(mask);     y2_s  = yCart.y2_kv(mask);
            
            if(exist('fl_norm','var') && ~isempty(fl_norm))                
                y1_s  = [min(y1_s);y1_s];
                y2_s  = [min(y2_s);y2_s];                
            end                        

            xl    = [(min(y1_s)-0.5) (max(y1_s)+0.5)];
            yl    = [(min(y2_s)-0.5) (max(y2_s)+0.5)];            
                                    
            for iSpecies=1:nSpecies
                
                fl_y1     = flux(1:this.N1*this.N2,iSpecies);
                fl_y2     = flux(this.N1*this.N2+1:end,iSpecies);
                
                if(strcmp(this.polar,'polar'))
                    [fl_y1,fl_y2] = GetCartesianFromPolar(fl_y1,fl_y2,this.Pts.y2_kv);                    
                end                
                
                fl_y1 = fl_y1(mask,:);  fl_y2 = fl_y2(mask,:);

                if(exist('fl_norm','var') && ~isempty(fl_norm))
                    O = ones(1,size(fl_y1,2));
                    fl_y1 = [fl_norm*O;fl_y1];
                    fl_y2 = [0*O;fl_y2];
                end            
            
                %fl_y1 = this.Interp.InterPol*flux(1:this.N1*this.N2,:);
                %fl_y2 = this.Interp.InterPol*flux(this.N1*this.N2+1:end,:);                                                
                
                %if(nSpecies > 1)                    
                %    subplot(nRows,nCol,iSpecies);
                %end

                if(exist('lw','var') && exist('c','var')) 
                    if(nSpecies == 1)
                        quiver(y1_s,y2_s,fl_y1,fl_y2,'LineWidth',lw,'Color',c);
                    else
                        quiver(y1_s,y2_s,fl_y1,fl_y2,'LineWidth',lw,'Color',c{iSpecies});
                    end
                else
                    quiver(y1_s,y2_s,fl_y1,fl_y2);
                end

                hold on;
                
                xlim(xl); ylim(yl);                    
                h = xlabel('$y_1$');  set(h,'Interpreter','Latex'); set(h,'fontsize',25);
                h = ylabel('$y_2$');  set(h,'Interpreter','Latex'); set(h,'fontsize',25);
                pbaspect([(xl(2)-xl(1)) (yl(2)-yl(1)) 1/2*min((xl(2)-xl(1)),(yl(2)-yl(1)))]);                
                title(['Species ' num2str(iSpecies)]);
                set(gca,'fontsize',20);                        
                set(gca,'linewidth',1.5);                                                             
            end                            
            hold off;   
                                            
        end            
        function doPlots(this,V,options,optDetails)
            %options: 'SC' , 'contour'
            
            nSpecies=size(V,2);
            if(nSpecies == 1)
                nCol = 1;
            else
                nCol = 2;
            end
            
            nRows  = ceil(nSpecies/nCol);                
            yCart  = GetCartPts(this,this.Interp.pts1,this.Interp.pts2);

            xl     = [(min(yCart.y1_kv)-0.5) (max(yCart.y1_kv)+0.5)];
            yl     = [(min(yCart.y2_kv)-0.5) (max(yCart.y2_kv)+0.5)];

            y1M    = reshape(yCart.y1_kv,this.Interp.Nplot2,this.Interp.Nplot1);
            y2M    = reshape(yCart.y2_kv,this.Interp.Nplot2,this.Interp.Nplot1);            

            for iSpecies=1:nSpecies
                
                if(nSpecies > 1)                    
                    subplot(nRows,nCol,iSpecies);
                end
                
                if(size(V,1) == length(this.Interp.pts1))
                    VI = V(:,iSpecies);
                else
                    VI = this.Interp.InterPol*V(:,iSpecies);
                end
                
                if((nargin >= 3) && strcmp(options,'contour'))
                    if(nargin >= 4)                        
                        [C,h] = contour(y1M,y2M,reshape(VI,...
                                  this.Interp.Nplot2,this.Interp.Nplot1),...
                                  optDetails.nContours,...
                                  'linewidth',1.5);  
                        if(isfield(optDetails,'linecolor'))
                            set(h,'Color',optDetails.linecolor);
                        end
                        if(isfield(optDetails,'clabel') && optDetails.clabel)
                            hc = clabel(C,h); set(hc,'fontsize',15);
                        end
                           
                    else
                        [C,h] = contour(y1M,y2M,reshape(VI,...
                                  this.Interp.Nplot2,this.Interp.Nplot1),...
                                  'linewidth',1.5);  
                    end
                    % hh = clabel(C,h,'fontsize',20);
                else
                    mesh(y1M,y2M,reshape(VI,...
                                  this.Interp.Nplot2,this.Interp.Nplot1));  
                end
                hold on;
                
                if((nargin >= 3) && strcmp(options,'SC'))
                    hold on; 
                    
                    mask    = ((this.Pts.y1_kv <= max(this.Interp.pts1)) & ...
                               (this.Pts.y1_kv >= min(this.Interp.pts1)) & ...
                               (this.Pts.y2_kv <= max(this.Interp.pts2)) & ...
                               (this.Pts.y2_kv >= min(this.Interp.pts2)));                            
                    ptsCart = GetCartPts(this);
                    Vp      = V(:,iSpecies);
                    h       = scatter3(ptsCart.y1_kv(mask),ptsCart.y2_kv(mask),...
                                                    Vp(mask),'o');
                    set(h,'MarkerEdgeColor','k','MarkerFaceColor','g');
                end
                
                xlim(xl); ylim(yl);                    
                h = xlabel('$y_1$');  set(h,'Interpreter','Latex'); set(h,'fontsize',25);
                h = ylabel('$y_2$');  set(h,'Interpreter','Latex'); set(h,'fontsize',25);
                pbaspect([(xl(2)-xl(1)) (yl(2)-yl(1)) 1/2*min((xl(2)-xl(1)),(yl(2)-yl(1)))]);                
                if(nSpecies > 1)
                    title(['Species ' num2str(iSpecies)]);
                end
                set(gca,'fontsize',20);                        
                set(gca,'linewidth',1.5);                        
                hold off;
            end            
        end    
        
        function PlotGrid(this,InitFig)            
            ptsCart = GetCartPts(this);                        
            h = scatter(ptsCart.y1_kv,ptsCart.y2_kv,'ob');              
            set(h,'MarkerEdgeColor','k','MarkerFaceColor','g');
            
            if((nargin == 2) && InitFig)
                y1lim = [min(ptsCart.y1_kv) max(ptsCart.y1_kv)];
                y2lim = [min(ptsCart.y2_kv) max(ptsCart.y2_kv)];

                xlim(y1lim + [-0.5 0.5]);
                ylim(y2lim + [-0.5 0.5]);

                pbaspect([(y1lim(2)-y1lim(1)) (y2lim(2)-y2lim(1)) 1]);
                set(gca,'fontsize',15);
            end
        end        
    end    
end


%         function M_conv = ComputeConvolutionMatrix_Pointwise(f,shapeParams)
%             
%             %*********************************************************************
%             %DESCRIPTION:
%             % computes matrix M_conv such that
%             %           M_conv * g_i = int f(y1-y1t,y2-y2t)*g(y1t,y2t) dy1t dy2t,
%             %INPUT:
%             %  f   = function for which convolution is to be computed
%             %  Pts = data for grid points in computational and physical space:
%             %        - 'y1_kv' - y1-variable for each point of 2D-grid 
%             %        - 'y2_kv' - y2-variable for each point of 2D-grid
%             %        - 'x1'    - grid in computational space only fo 1st variable
%             %        - 'x2'    - grid in computational space only for 2nd variable
%             %  Int = Integration weight vector
%             %  MapSub.PhysSpace1(y10,y20,x1,optsPhys)
%             %  MapSub.PhysSpace2(y10,y20,x2,optsPhys)
%             %OUTPUT:
%             % M_conv = convolution matrix, size (N1*N2,N1*N2) , see above
%             %*********************************************************************
% 
%             disp('Computing Convolution matrices...'); 
% 
%             n1 = this.N1;   n2 = this.N2;
%             M_conv = zeros(n1*n2,n1*n2);  
% 
%             %2) Loop over all points
%             for i=1:(n1*n2)
%                 y10 = this.Pts.y1_kv(i); 
%                 y20 = this.Pts.y2_kv(i);
% 
%                 %2a) Compute points in subgrid
%                 subConvShape  = GetConvShape(y10,y20,shapeParams);               
% 
%                 %2b) Compute f-values        
%                 fP          = f(norm([y10 - subConvShape.Pts.y1_kv,y20 - subConvShape.Pts.y2_kv]));
% 
%                 %2c) Compute Interpolation Matrix onto Subspace
%                 IP          = SubShapePts(this,subConvShape.Pts);  
% 
%                 %2d) Compute integration weight vector
%                 Int_i       = subConvShape.ComputeIntegrationVector();
%                 
%                 %2e) Combine
%                 M_conv(i,:) = (Int_i.*fP')*IP;    
%             end
%             M_conv(isnan(M_conv)) = 0;
%             
%         end